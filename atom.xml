<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Han1254</title>
  
  <subtitle>走在成为极客的路上。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-16T05:51:15.026Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Han1254</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode_有效括号</title>
    <link href="http://yoursite.com/2019/05/16/leetcode-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/05/16/leetcode-有效括号/</id>
    <published>2019-05-16T05:47:11.000Z</published>
    <updated>2019-05-16T05:51:15.026Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<br><a id="more"></a></p><blockquote><p>示例 1:<br>输入: “()”<br>输出: true  </p></blockquote><blockquote><p>示例 2:<br>输入: “()[]{}”<br>输出: true  </p></blockquote><blockquote><p>示例 3:<br>输入: “(]”<br>输出: false  </p></blockquote><blockquote><p>示例 4:<br>输入: “([)]”<br>输出: false  </p></blockquote><blockquote><p>示例 5:<br>输入: “{[]}”<br>输出: true  </p></blockquote><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"></span><br><span class="line">     public boolean isValid(String s)&#123;</span><br><span class="line">         Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;;</span><br><span class="line">         for (char alp : s.toCharArray())&#123;</span><br><span class="line">             if(alp == &apos;(&apos; )&#123;</span><br><span class="line">                 stack.push(&apos;)&apos;);</span><br><span class="line">             &#125;else if(alp == &apos;&#123;&apos;)&#123;</span><br><span class="line">                 stack.push(&apos;&#125;&apos;);</span><br><span class="line">             &#125;else if(alp == &apos;[&apos;)&#123;</span><br><span class="line">                 stack.push(&apos;]&apos;);</span><br><span class="line">             &#125;else if(stack.isEmpty()||stack.pop()!= alp)&#123;</span><br><span class="line">                 return false;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return stack.isEmpty();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不长，一点一点看 </p><h2 id="首先，建立一个栈实例stack"><a href="#首先，建立一个栈实例stack" class="headerlink" title="首先，建立一个栈实例stack"></a>首先，建立一个栈实例stack</h2><p>记住他是后进先出<br>不了解Stack和Character的同学请点击<br>–&gt;<a href="http://www.runoob.com/java/java-stack-class.html" target="_blank" rel="noopener">Stack类</a><br>–&gt;<a href="http://www.runoob.com/java/java-character.html" target="_blank" rel="noopener">Character类</a></p><p>有了一个栈，我们就有空去装东西了。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>for循环里进行遍历，我们首先假设这个字符串是”( ( ( { } ) ) ) }”,那么结合实例，接下来代码的主要思想是：</p><ul><li>如果我遇到一个左括号，就往栈里加一个与这对应的右括号</li><li>如果是右括号，比如第五个括号，那么就跟栈顶元素对比并且顶部元素出栈（栈是后进先出的，第五个括号是跟第四个对应的，所以遍历到第四个时往栈里添加的括号按照常理应该是跟第五个一样的）<ul><li>如果对比不一样，false</li></ul></li><li>由于对比一次就出栈一次，如果出完了，stack说自己一滴都不剩了，可alp居然还在遍历，有问题，原来的字符串绝对是奇数个字符，false</li><li>如果运行到最后，没啥问题，判断stack,如果还剩元素，说明原来的右括号比左括号少，直接返回stack.isEmpty()就行了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;br&gt;有效字符串需满足：&lt;br&gt;左括号必须用相同类型的右括号闭合。&lt;br&gt;左括号必须以正确的顺序闭合。&lt;br&gt;注意空字符串可被认为是有效字符串。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
      <category term="有效括号" scheme="http://yoursite.com/categories/Leetcode/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android-px_dp</title>
    <link href="http://yoursite.com/2019/04/20/Android-px-dp/"/>
    <id>http://yoursite.com/2019/04/20/Android-px-dp/</id>
    <published>2019-04-20T13:16:10.000Z</published>
    <updated>2019-05-06T13:45:28.942Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>DeBug日志-Android-用户名只能是数字</title>
    <link href="http://yoursite.com/2019/04/02/DeBug%E6%97%A5%E5%BF%97-Android-%E7%94%A8%E6%88%B7%E5%90%8D%E5%8F%AA%E8%83%BD%E6%98%AF%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2019/04/02/DeBug日志-Android-用户名只能是数字/</id>
    <published>2019-04-02T01:57:40.000Z</published>
    <updated>2019-04-02T01:57:40.604Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第四周学习进度</title>
    <link href="http://yoursite.com/2019/03/30/%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6/"/>
    <id>http://yoursite.com/2019/03/30/第四周学习进度/</id>
    <published>2019-03-30T12:57:46.000Z</published>
    <updated>2019-03-31T01:17:03.659Z</updated>
    
    <content type="html"><![CDATA[<p>因为有两张图片存在本地看不了，我已经把这个上传到博客里了，如果学长要看的话就点击<br>–&gt;<a href="https://han1254.github.io/2019/03/30/第四周学习进度/#more" target="_blank" rel="noopener">第四周学习进度</a></p><h1 id="本周学习进度"><a href="#本周学习进度" class="headerlink" title="本周学习进度"></a>本周学习进度</h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android:"></a>Android:</h2><ul><li>ReBy的登陆和注册功能基本完成。使用了SQLite方法进行数据储存。不足之处：还没有实现自动登陆功能。  </li><li><p>在学长的帮助下，利用Debug功能修改代码。<br>–&gt;<a href="https://han1254.github.io/2019/03/30/Debug日志-Android-SQLite/#more" target="_blank" rel="noopener">Debug日志-Android-SQLite</a></p></li><li><p>学习了利用Cursor的moveToFirst()方法，判断账号是否已经存在于数据库中，cursor的具体实现原理我写到了gitbub中。<br>–&gt;<a href="https://github.com/han1254/Study/blob/master/Android/Cursor那点事.md" target="_blank" rel="noopener">Cursor那点事</a></p></li><li>在学长的指导下，学习使用values,里面的数据相当于是全局变量，通过引用，方便以后的数据更改，从而使自己的代码更加规范。</li></ul><hr><p>除此之外，在写app的过程中，还学习了一些比较小的技巧。</p><ul><li>trim函数</li><li>设置下划线和光标的颜色</li><li>设置按钮的描边</li><li>设置Edittext的输入限制  </li><li>状态栏的透明与半透明</li><li>ActionBar的删除  </li><li>状态栏的颜色设置</li><li>活动的启动模式</li><li>密码的隐藏</li><li>git删除远程仓库的文件夹<br>这些小技巧的用法我已经总结下来并且传到了github中。<br>–&gt;<a href="https://github.com/han1254/Study/blob/master/Android/LittleTip.md" target="_blank" rel="noopener">LittleTip</a></li></ul><hr><h1 id="下周计划："><a href="#下周计划：" class="headerlink" title="下周计划："></a>下周计划：</h1><h2 id="Reby"><a href="#Reby" class="headerlink" title="Reby"></a>Reby</h2><ul><li>完成自动登陆功能</li><li>利用Fragment完成利用底部导航栏进行界面切换的功能。</li><li>完成推出登陆功能<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2>由于上半学期一直没好好学算法，导致自己的工很不扎实。下周开始，利用PTA，尽量达到每一到两天一道算法题（利用Java和C++都实现一下）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为有两张图片存在本地看不了，我已经把这个上传到博客里了，如果学长要看的话就点击&lt;br&gt;–&amp;gt;&lt;a href=&quot;https://han1254.github.io/2019/03/30/第四周学习进度/#more&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="学习进度" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Debug日志-Android-SQLite</title>
    <link href="http://yoursite.com/2019/03/30/Debug%E6%97%A5%E5%BF%97-Android-SQLite/"/>
    <id>http://yoursite.com/2019/03/30/Debug日志-Android-SQLite/</id>
    <published>2019-03-30T10:54:04.000Z</published>
    <updated>2019-03-30T11:06:58.567Z</updated>
    
    <content type="html"><![CDATA[<p>三月二十九日，遇到了一个关于SQLite的Bug。<br><a id="more"></a><br><img src="/2019/03/30/Debug日志-Android-SQLite/bug2.PNG" alt><br>其结果就是，每次我在登陆界面只要一填完账号密码，再点击登陆，就会闪退。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">package com.example.reby;</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line">public class LoginActivity extends AppCompatActivity implements View.OnClickListener &#123;</span><br><span class="line">    private EditText edit_account, edit_password;</span><br><span class="line">    private Button btn_login,btn_register;</span><br><span class="line">    private DBHelper dbHelper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        //设置状态栏的全透明</span><br><span class="line">       /* if (Build.VERSION.SDK_INT &gt;= 21) &#123;</span><br><span class="line">           View decorView = getWindow().getDecorView();</span><br><span class="line">           decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class="line">           getWindow().setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">        &#125;*/</span><br><span class="line">       //设置状态栏的半透明</span><br><span class="line">        if(Build.VERSION.SDK_INT &gt;= 21) &#123;</span><br><span class="line">            getWindow().setFlags(</span><br><span class="line">                    WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,</span><br><span class="line">                    WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        &#125;</span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line">        ActionBar actionBar = getSupportActionBar();</span><br><span class="line">        if(actionBar != null)&#123;</span><br><span class="line">            actionBar.hide();</span><br><span class="line">        &#125;</span><br><span class="line">        activityInit();</span><br><span class="line">    &#125;</span><br><span class="line">    public void activityInit()&#123;</span><br><span class="line">        edit_account = (EditText) findViewById(R.id.et_login_account);</span><br><span class="line">        edit_account.setOnEditorActionListener(new TextView.OnEditorActionListener()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123;</span><br><span class="line">                if(actionId == EditorInfo.IME_ACTION_DONE)&#123;</span><br><span class="line">                    edit_account.clearFocus();</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        edit_password = (EditText)findViewById(R.id.et_login_password);</span><br><span class="line">        //密码隐藏</span><br><span class="line">        edit_password.setTransformationMethod(PasswordTransformationMethod.getInstance());</span><br><span class="line">        edit_password.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123;</span><br><span class="line">                if(actionId == EditorInfo.IME_ACTION_DONE)&#123;</span><br><span class="line">                    edit_password.clearFocus();</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_login = (Button)findViewById(R.id.btn_login);</span><br><span class="line">        btn_register = (Button)findViewById(R.id.btn_sign_up);</span><br><span class="line">        btn_login.setOnClickListener(this);</span><br><span class="line">        btn_register.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view)&#123;</span><br><span class="line">        switch(view.getId())&#123;</span><br><span class="line">            case R.id.btn_login:</span><br><span class="line">                if(edit_account.getText().toString().trim().equals(&quot;&quot;)|edit_password.getText().toString().trim().equals(&quot;&quot;))&#123;</span><br><span class="line">                    Toast.makeText(this,&quot;请完善您的信息&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    userInfoIsRight();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case R.id.btn_sign_up:</span><br><span class="line">                Intent intent = new Intent(LoginActivity.this, RegisterActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    protected void userInfoIsRight()&#123;</span><br><span class="line">        if(isRight(edit_account.getText().toString(),edit_password.getText().toString()))&#123;</span><br><span class="line">            Intent i = new Intent(LoginActivity.this,MainActivity.class);</span><br><span class="line">            startActivity(i);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Toast.makeText(this,&quot;账号或密码错误&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isRight(String edit_account, String edit_password)&#123;</span><br><span class="line">        dbHelper=new DBHelper(this,DBHelper.DATABASE_NAME,null,DBHelper.DATABASE_VERSION);//对dbHelper进行实体化</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        String sql = &quot;Select * from usertable where username = ? and password = ?&quot;;</span><br><span class="line">        Cursor cursor = db.rawQuery(sql, new String[]&#123;edit_account, edit_password&#125;);</span><br><span class="line">        if(cursor.moveToFirst())&#123;</span><br><span class="line">            cursor.close();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在金韬学长的帮助下，我成功找到了Bug<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br></pre></td></tr></table></figure></p><p>我在之前只是声明了dbHelper,但是并没有给他任何实体，所以它不能调用方法。<br>修改方案就是给它一个实体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dbHelper=new DBHelper(this,DBHelper.DATABASE_NAME,null,DBHelper.DATABASE_VERSION);//对dbHelper进行实体化</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br></pre></td></tr></table></figure></p><p>然后就成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三月二十九日，遇到了一个关于SQLite的Bug。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Debug/"/>
    
      <category term="Android" scheme="http://yoursite.com/categories/Debug/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Debug" scheme="http://yoursite.com/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>Cusor那点事</title>
    <link href="http://yoursite.com/2019/03/30/Cusor%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>http://yoursite.com/2019/03/30/Cusor那点事/</id>
    <published>2019-03-29T23:20:58.000Z</published>
    <updated>2019-03-30T11:17:46.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cusor那点事"><a href="#Cusor那点事" class="headerlink" title="Cusor那点事"></a>Cusor那点事</h1><a id="more"></a><p>今天写一个登陆界面，到最后判断账号密码的时候，看了一些别人的源码，用到了下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean isRight(String edit_account, String edit_password)&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        String sql = &quot;Select * from usertable where username = ? and password = ?&quot;;</span><br><span class="line">        Cursor cursor = db.rawQuery(sql, new String[]&#123;edit_account, edit_password&#125;);</span><br><span class="line">        if(cursor.moveToFirst())&#123;</span><br><span class="line">            cursor.close();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><em>emmm~ Cusor 王德发！！！！！这是啥 ?</em><br>上网搜索了一下，cusor是英语‘光标’的意思  </p><hr><h2 id="关于-Cursor"><a href="#关于-Cursor" class="headerlink" title="关于 Cursor"></a>关于 Cursor</h2><p>在你理解和使用 Android Cursor 的时候你必须先知道关于 Cursor 的几件事情：<br>Cursor 是每行的集合。使用 moveToFirst() 定位第一行。你必须知道每一列的名称。你必须知道每一列的数据类型。Cursor 是一个随机的数据源。所有的数据都是通过下标取得。   </p><blockquote><p>关于 Cursor 的重要方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">c.move(int offset); //以当前位置为参考,移动到指定行  </span><br><span class="line">c.moveToFirst();    //移动到第一行  </span><br><span class="line">c.moveToLast();     //移动到最后一行  </span><br><span class="line">c.moveToPosition(int position); //移动到指定行  </span><br><span class="line">c.moveToPrevious(); //移动到前一行  </span><br><span class="line">c.moveToNext();     //移动到下一行  </span><br><span class="line">c.isFirst();        //是否指向第一条  </span><br><span class="line">c.isLast();     //是否指向最后一条  </span><br><span class="line">c.isBeforeFirst();  //是否指向第一条之前  </span><br><span class="line">c.isAfterLast();    //是否指向最后一条之后  </span><br><span class="line">c.isNull(int columnIndex);  //指定列是否为空(列基数为0)  </span><br><span class="line">c.isClosed();       //游标是否已关闭  </span><br><span class="line">c.getCount();       //总数据项数  </span><br><span class="line">c.getPosition();    //返回当前游标所指向的行数  </span><br><span class="line">c.getColumnIndex(String columnName);//返回某列名对应的列索引值，如果不存在返回-1  </span><br><span class="line">c.getString(int columnIndex);   //返回当前行指定列的值  </span><br><span class="line">c·getColumnIndexOrThrow(String columnName)——从零开始返回指定列名称，如果不存在将抛出IllegalArgumentException 异常。</span><br><span class="line">c.close()——关闭游标，释放资源</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>关于cusor的应用，可以看看以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Button query=(Button) findViewById(R.id.query_data);</span><br><span class="line">        query.setOnClickListener(new OnClickListener()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                SQLiteDatabase db=dbHelper.getWritableDatabase();</span><br><span class="line">                //查询Book表中的所有的数据</span><br><span class="line">                //Cursor cursor=db.query(&quot;Book&quot;, null, null, null, null, null, null);</span><br><span class="line">                Cursor cursor=db.rawQuery(&quot;Select * from Book&quot;, null);</span><br><span class="line">                if(cursor.moveToFirst())&#123;</span><br><span class="line">                    do&#123;</span><br><span class="line">                        //遍历Cursor对象，取出数据并打印</span><br><span class="line">                        String name=cursor.getString(cursor.getColumnIndex(&quot;name&quot;));</span><br><span class="line">                        String author=cursor.getString(cursor.getColumnIndex(&quot;author&quot;));</span><br><span class="line">                        int pages=cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;));</span><br><span class="line">                        double price=cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;));</span><br><span class="line">                        Log.d(&quot;MainActivity&quot;,&quot;book name is&quot;+name);</span><br><span class="line">                        Log.d(&quot;MainActivity&quot;,&quot;book author is&quot;+author);</span><br><span class="line">                        Log.d(&quot;MainActivity&quot;,&quot;book pages is&quot;+pages);</span><br><span class="line">                        Log.d(&quot;MainActivity&quot;,&quot;book price is&quot;+price);</span><br><span class="line">                    &#125;while(cursor.moveToNext());</span><br><span class="line">                &#125;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>访问Cusor的下标获取数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int nameColumnIndex = cur.getColumnIndex(People.NAME);</span><br><span class="line">String name = cur.getString(nameColumnIndex);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>循环 Cursor 取出我们需要的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(cur.moveToNext()) &#123;</span><br><span class="line">    //光标移动成功</span><br><span class="line">   String email = cursor.getString(cursor.getColumnIndex(RuiXin.EMAIL));</span><br><span class="line">   startManagingCursor(cursor);  //查找后关闭游标 </span><br><span class="line">   //把数据取出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>当cur.moveToNext() 为假时将跳出循环，即 Cursor 数据循环完毕</p><blockquote><p>用 for 循环而不想用While 循环  </p></blockquote><p>·isBeforeFirst()——返回游标是否指向之前第一行的位置<br>·isAfterLast()——返回游标是否指向第最后一行的位置<br>·isClosed()——如果返回 true 即表示该游戏标己关闭<br>有了以上的方法，可以如此取出数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(cur.moveToFirst();!cur.isAfterLast();cur.moveToNext())</span><br><span class="line">&#123;</span><br><span class="line">    int nameColumn = cur.getColumnIndex(People.NAME);</span><br><span class="line">    int phoneColumn = cur.getColumnIndex(People.NUMBER);</span><br><span class="line">    String name = cur.getString(nameColumn);</span><br><span class="line">    String phoneNumber = cur.getString(phoneColumn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="Cusor解析"><a href="#Cusor解析" class="headerlink" title="Cusor解析"></a>Cusor解析</h2><p>一般情况下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDataBase  </span><br><span class="line"> db;   </span><br><span class="line">Cursor  </span><br><span class="line"> cursor = db.query(各种参数);</span><br></pre></td></tr></table></figure></p><p>这时，就出现了网上的解释了，说cursor是每行的集合。<br>现在先解释一下SQLite数据库中是怎么存放数据的，是以表的形式存放的，看这个表Student  </p><p>position | id | name | gender | age | city<br>|–|–|—|–|–|–|<br>0 |1 |张三| 男|19|山东<br>1|2|李四|男|20|上海<br>3|4|王五|男|34|广西<br>4|5|牛大花|女|17|天津<br>5|6|光绪|男|24|北京<br>所以这个每行的集合的意思，是获得的满足条件（就是我们query方法中传入的条件参数）的所有行。<br>比如我要在这个表中找gender为男的，那么获得到的cursor就包含了张三行，李四行，王五行，光绪行。   </p><hr><h3 id="遍历cursor内容的时候，为什么要先moveToFirst-？"><a href="#遍历cursor内容的时候，为什么要先moveToFirst-？" class="headerlink" title="遍历cursor内容的时候，为什么要先moveToFirst()？"></a>遍历cursor内容的时候，为什么要先moveToFirst()？</h3><p>我们不进行moveToFirst()操作，我们获取游标对象后，直接输出它当前的position值<br><img src="https://img-blog.csdn.net/20161201150546871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>可以看到，输出的值是-1。  </p><p>position | id | name | gender | age | city<br>|–|–|—|–|–|–|<br>-1 |null|null|null|null|null<br>0 |1 |张三| 男|19|山东<br>1|2|李四|男|20|上海<br>3|4|王五|男|34|广西<br>4|5|牛大花|女|17|天津<br>5|6|光绪|男|24|北京<br>也就是说，现在光标在第零行之前。<br>所以我们使用moveToFirst后在输出position就会发现position=0了，使用moveToNext也可以。   </p><hr><h3 id="moveToNext如何得知是否已经遍历完毕呢？"><a href="#moveToNext如何得知是否已经遍历完毕呢？" class="headerlink" title="moveToNext如何得知是否已经遍历完毕呢？"></a>moveToNext如何得知是否已经遍历完毕呢？</h3><p>我们翻看源码，会发现moveToFirst，moveToNext，moveToLast，moveToPrevious等最后都会执行到这个方法<br><img src="https://img-blog.csdn.net/20161201161718716" alt><br>图中说的：这个对象在初始化的时候，指的就是当前页面的那个对象。mPos=-1被写在一个空参构造方法里了。<br>看源码的时候也能发现：<br>moveToFirst调用的是moveToPosition（0）<br>moveToNext调用的是moveToPosition（mPos+1)<br>所以如果是第一次调用的话，这两句话的意思是一样的（开始mPos=-1）。   </p><h3 id="那么现在来看之前的代码"><a href="#那么现在来看之前的代码" class="headerlink" title="那么现在来看之前的代码"></a>那么现在来看之前的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(cursor.moveToFirst())&#123;//用来判断是否遍历并且是否存在这样一组account&amp;password</span><br><span class="line">            cursor.close();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br></pre></td></tr></table></figure><hr><p>本文参考文章<br><a href="https://blog.csdn.net/android_zyf/article/details/53420267" target="_blank" rel="noopener">Android中的Cursor到底是什么？如何理解Cursor的方法都在做什么事情？</a><br><a href="https://www.cnblogs.com/wugu-ren/p/6113773.html" target="_blank" rel="noopener">Android笔记——关于Cursor类的介绍 </a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Cusor那点事&quot;&gt;&lt;a href=&quot;#Cusor那点事&quot; class=&quot;headerlink&quot; title=&quot;Cusor那点事&quot;&gt;&lt;/a&gt;Cusor那点事&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="cusor" scheme="http://yoursite.com/tags/cusor/"/>
    
      <category term="SQLite" scheme="http://yoursite.com/tags/SQLite/"/>
    
  </entry>
  
  <entry>
    <title>代码规范</title>
    <link href="http://yoursite.com/2019/03/29/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2019/03/29/代码规范/</id>
    <published>2019-03-29T15:39:09.000Z</published>
    <updated>2019-03-29T15:41:38.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="没有规矩不成方圆"><a href="#没有规矩不成方圆" class="headerlink" title="没有规矩不成方圆"></a>没有规矩不成方圆</h1><a id="more"></a><h1 id="JAVA代码规范"><a href="#JAVA代码规范" class="headerlink" title="JAVA代码规范"></a>JAVA代码规范</h1><h2 id="强制性规范"><a href="#强制性规范" class="headerlink" title="强制性规范:"></a>强制性规范:</h2><ul><li>代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。  </li><li>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。   </li><li>类名使用UpperCamelCase 风格，必须遵从驼峰形式。  </li><li>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。  </li><li>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长例如：MAX_STOCK_COUNT。  </li><li>抽象类命名使用 Abstract 或 Base 开头;异常类命名使用 Exception 结尾;测试类 命名以它要测试的类的名称开始。  </li><li>杜绝不规范的英文缩写：AbstractClass 缩写成AbsClass；condition缩写成condi;此类随意缩写严重降低了代码的可阅读性。  </li><li>如果使用到了设计模式，建议在类名中体现出具体的模式。</li></ul><hr><h1 id="Android代码规范"><a href="#Android代码规范" class="headerlink" title="Android代码规范"></a>Android代码规范</h1><ul><li><p>Activity 命名一律使用 模块名+Activity 的方式。例如，LoginActivity、SignupActivity；</p></li><li><p>Fragment 命名一律使用 模块名+Fragment 的方式；<br>自定义View：Custom(建议)+功能名+View/ViewGroup(具体的组件名称)。例如：CustomImageScroller、CustomRatingBar。</p></li><li><p>Widget 小组件：ScanWidget、WeatherWidget。</p></li><li><p>Dialog对话框：功能名+Dialog。例如：LoginDialog、ProgressDialog</p></li><li><p>尽量在每一个Activity或类中加入TAG,方便我们查看Activity的信息。(Tip : 使用Android Studio提供的快捷键logt可快速生成当前 类的常量)  </p></li><li>对于使用Intent传递数据，声明一些Key的时候，EXTRA_KEY_+具体Key名称。</li><li>所有的常量加上注释，且功能相同的排放在一起，不同的进行换行；<br>Activity中变量采用m开头+类名。例如，mTable、mPerson；  </li><li>Activity中的控件：m+模块名+控件类型名称。例如，mLoginEditText,mLoginTextView;</li></ul><hr><h1 id="资源Res"><a href="#资源Res" class="headerlink" title="资源Res"></a>资源Res</h1><p>1.按照资源的类型，分为以下几种</p><blockquote><p>控件Id命名：控件缩写 _模块（module) _功能名(function)   </p></blockquote><p>控件类型|ID命名规则<br>|—|—|<br>TextView | tv_module_function<br>EditText | et_module_function<br>ImageView | iv_module_function<br>Button | btn_module_function<br>ListView | lv_module_function<br>GridView | gv_module_function<br>CheckBox | check_module_function<br>RadioButton | radio_module_function<br>LinearLayout| ll_module_function<br>RelativeLayout | rl_module_function<br>FrameLayout | fl_module_function<br>GridLayout | gl_module_function</p><hr><blockquote><p>Drawable资源命名  </p></blockquote><table><thead><tr><th>Resources Type</th><th>命名规则</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>launcher icon | ic_launcher。例R.drawable.ic_launcher<br>normal icon | ic_具体模块_功能。例R.drawable.ic_audio_pause<br>Toolbar icon | ic_ab_功能名。例如ic_ab_search<br>selector | selector_模块_功能名。例如 selector_login_button<br>shape | shape_模块功能名状态。例如 R.drawable.shape_login_button_normal</p><blockquote><p>Layout命名   </p></blockquote><table><thead><tr><th>类型</th><th>命名规则</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>activity | activity_模块名。例如 R.layout.activity_login<br>fragment | fragment_模块名。例如 R.layout.fragment_login_layout_header<br>include | layout_模块名_功能名。例如 @layout/layout_login_bottom<br>adapter | adapter_item_模块名_功能名。例如 R.layout.adapter_item_simple_text<br>dialog | dialog_模块_功能名。例如 R.layout.dialog_time_picker<br>list header | header_模块_功能。例如 R.layout.header_main_top_ad<br>list footer | footer_模块_功能。例如 R.layout.footer_main_bottom_action<br>widget | widget_模块_功能。例如 R.layout.widget_app_clock</p><blockquote><p>Menu资源命名  </p></blockquote><p>Resources Type | 命名规则<br>|–|–|<br>menu | menu_模块名。例如 menu_login</p><blockquote><p>Value资源命名 </p></blockquote><p>Resources Type | 命名规则<br>|–|–|<br>color | 模块名_color。例如 material_design_color<br>dimens | 模块名_dimens。例如 material_design_dimens<br>style | 模块名_style。例如 material_design_style<br>themes | 模块名_themes。例如 material_design_themes</p><hr><h1 id="当然这只是一部分，更多的请移步"><a href="#当然这只是一部分，更多的请移步" class="headerlink" title="当然这只是一部分，更多的请移步"></a>当然这只是一部分，更多的请移步</h1><p><a href="https://www.jianshu.com/p/f5a55dff62f0" target="_blank" rel="noopener">这可能是史上最全的Android代码规范</a><br><a href="https://github.com/liuzhanta/Android-Developer-Books/blob/master/Books_Java/阿里巴巴Java开发手册.pdf" target="_blank" rel="noopener">阿里Java开发手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;没有规矩不成方圆&quot;&gt;&lt;a href=&quot;#没有规矩不成方圆&quot; class=&quot;headerlink&quot; title=&quot;没有规矩不成方圆&quot;&gt;&lt;/a&gt;没有规矩不成方圆&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="规范" scheme="http://yoursite.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit</title>
    <link href="http://yoursite.com/2019/03/29/Retrofit/"/>
    <id>http://yoursite.com/2019/03/29/Retrofit/</id>
    <published>2019-03-29T15:34:19.000Z</published>
    <updated>2019-03-29T15:35:52.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Retrofit-2-0-使用教程"><a href="#Retrofit-2-0-使用教程" class="headerlink" title="Retrofit 2.0 使用教程"></a>Retrofit 2.0 使用教程</h1><a id="more"></a><p>搬运自<br><a href="https://blog.csdn.net/carson_ho/article/details/73732076" target="_blank" rel="noopener">这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解)</a><br><a href="https://www.jianshu.com/p/c99dbf612740" target="_blank" rel="noopener">网络请求框架 —— Retrofit</a></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>在Andrroid开发中，网络请求十分常用  </li><li>而在Android网络请求库中，Retrofit是当下最热的一个网络请库  </li><li>下图是它的依赖库<br><img src="http://upload-images.jianshu.io/upload_images/944365-9be33c763c56a914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依赖库"></li></ul><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><img src="http://upload-images.jianshu.io/upload_images/944365-2bd80b234ae9d155.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片">   </p><hr><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><img src="http://upload-images.jianshu.io/upload_images/944365-a3109ad0446b0540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简介"><br>注意：</p><ul><li>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。</li><li>网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责 网络请求接口的封装<br>本质流程<br><img src="http://upload-images.jianshu.io/upload_images/944365-b5194f1d16673589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="progess">  </li><li>App应用程序通过 Retrofit 请求网络，实际上是使用 Retrofit 接口层封装请求参数、Header、Url 等信息，之后由 OkHttp 完成后续的请求操作</li><li>在服务端返回数据之后，OkHttp 将原始的结果交给 Retrofit，Retrofit根据用户的需求对结果进行解析</li></ul><hr><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>使用 Retrofit 的步骤共有7个：</p><p>步骤1：添加 依赖<br>步骤2：创建 接收服务器返回数据的类<br>步骤3：创建 用于描述网络请求的接口<br>步骤4：创建 Retrofit 实例<br>步骤5：创建 网络请求接口实例并配置网络请求参数<br>步骤6：发送 网络请求（异步 / 同步） </p><h3 id="步骤一-前期准备"><a href="#步骤一-前期准备" class="headerlink" title="步骤一 前期准备"></a>步骤一 前期准备</h3><h4 id="1）添加依赖"><a href="#1）添加依赖" class="headerlink" title="1）添加依赖"></a>1）添加依赖</h4><ul><li>okHttp依赖</li><li>Gson依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;</span><br><span class="line">    // Retrofit库</span><br><span class="line">    implementation &apos;com.squareup.okhttp3:okhttp:3.10.0&apos;</span><br><span class="line">    // Okhttp库</span><br><span class="line">    implementation &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;</span><br><span class="line">    //Gson库</span><br></pre></td></tr></table></figure></li></ul><h4 id="2）添加网络权限"><a href="#2）添加网络权限" class="headerlink" title="2）添加网络权限"></a>2）添加网络权限</h4><p><em>AndroidManifest.xml</em><br><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code>  </p><hr><h3 id="步骤二：创建-接收服务器返回数据的类"><a href="#步骤二：创建-接收服务器返回数据的类" class="headerlink" title="步骤二：创建 接收服务器返回数据的类"></a>步骤二：创建 接收服务器返回数据的类</h3><p>接下来看一个实例</p><blockquote><p>获取一下都有哪些大神对 Retrofit 做出了贡献  </p></blockquote><p>1)创建 Java 类对象Contrbutor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Contributor &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * login : JakeWharton</span><br><span class="line">     * avatar_url : https://avatars0.githubusercontent.com/u/66577?v=4</span><br><span class="line">     * html_url : https://github.com/JakeWharton</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private String login;  // 人名</span><br><span class="line">    private String avatar_url;  // 头像的 Url 地址</span><br><span class="line">    private String html_url;  // 个人 GitHub 主页地址</span><br><span class="line">    </span><br><span class="line">    public String getLogin() &#123;</span><br><span class="line">        return login;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLogin(String login) &#123;</span><br><span class="line">        this.login = login;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAvatar_url() &#123;</span><br><span class="line">        return avatar_url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAvatar_url(String avatar_url) &#123;</span><br><span class="line">        this.avatar_url = avatar_url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getHtml_url() &#123;</span><br><span class="line">        return html_url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHtml_url(String html_url) &#123;</span><br><span class="line">        this.html_url = html_url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这里使用了GsonFormat进行自动构建类<br>详情参考:  </p></blockquote><h2 id="还在手动写Bean？赶紧来用GsonFormat吧"><a href="#还在手动写Bean？赶紧来用GsonFormat吧" class="headerlink" title="还在手动写Bean？赶紧来用GsonFormat吧   "></a><a href="https://blog.csdn.net/u013700502/article/details/78765574" target="_blank" rel="noopener">还在手动写Bean？赶紧来用GsonFormat吧</a>   </h2><h3 id="步骤三-创建-API-接口（GitHub-提供的是-GET-请求）"><a href="#步骤三-创建-API-接口（GitHub-提供的是-GET-请求）" class="headerlink" title="步骤三  创建 API 接口（GitHub 提供的是 GET 请求）"></a>步骤三  创建 API 接口（GitHub 提供的是 GET 请求）</h3><p>Retrofit将 Http请求 抽象成 Java接口：采用 注解 描述网络请求参数 和配置网络请求参数  </p><blockquote><p>用 动态代理 动态 将该接口的注解“翻译”成一个 Http 请求，最后再执行 Http 请求<br>  注：接口中的每个方法的参数都需要使用注解标注，否则会报错</p></blockquote><p><em>GetRequest_Interface.interface</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface MainService &#123;</span><br><span class="line"></span><br><span class="line">    @GET(&quot;/repos/square/retrofit/contributors&quot;)</span><br><span class="line">    Call&lt;List&lt;Contributor&gt;&gt; getCall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>—&gt;Retrofit 网络请求接口的注解类型<br><img src="http://upload-images.jianshu.io/upload_images/944365-ee747d1e331ed5a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tu"><br><img src="http://upload-images.jianshu.io/upload_images/944365-f9f8994497df7fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kdj"></p><h3 id="步骤四，五，六：创建-Retrofit-实例-异步和同步我不太清楚"><a href="#步骤四，五，六：创建-Retrofit-实例-异步和同步我不太清楚" class="headerlink" title="步骤四，五，六：创建 Retrofit 实例(异步和同步我不太清楚)"></a>步骤四，五，六：创建 Retrofit 实例(异步和同步我不太清楚)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void initData() &#123;</span><br><span class="line">    // 创建一个非常简单的REST适配器，它指向 GitHub 的 API</span><br><span class="line">    Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">            .baseUrl(API_URL)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    // 创建一个我们的 GitHub API 接口的实例。</span><br><span class="line">    MainService service = retrofit.create(MainService.class);</span><br><span class="line"></span><br><span class="line">    // 创建一个调用实例来查找都有哪些大神对 Retrofit 做出了贡献。</span><br><span class="line">    Call&lt;List&lt;Contributor&gt;&gt; call = service.getCall();</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    //发送网络请求(异步)</span><br><span class="line">    call.enqueue(new Callback&lt;List&lt;Contributor&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onResponse(Call&lt;List&lt;Contributor&gt;&gt; call, Response&lt;List&lt;Contributor&gt;&gt; response) &#123;</span><br><span class="line">            if (response.isSuccessful()) &#123;</span><br><span class="line">                </span><br><span class="line">                list = response.body();</span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">                if (list != null &amp;&amp; list.size() &gt; 0) &#123;</span><br><span class="line">                    mAdapter.setData(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(Call&lt;List&lt;Contributor&gt;&gt; call, Throwable t) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>差不多就是这样了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Retrofit-2-0-使用教程&quot;&gt;&lt;a href=&quot;#Retrofit-2-0-使用教程&quot; class=&quot;headerlink&quot; title=&quot;Retrofit 2.0 使用教程&quot;&gt;&lt;/a&gt;Retrofit 2.0 使用教程&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Map类</title>
    <link href="http://yoursite.com/2019/03/29/Map%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/03/29/Map类/</id>
    <published>2019-03-29T15:24:56.000Z</published>
    <updated>2019-03-29T15:26:37.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Map类的使用方法"><a href="#Android-Map类的使用方法" class="headerlink" title="Android Map类的使用方法"></a>Android Map类的使用方法</h1><a id="more"></a><p>在Android系统中，有着多种存储数据的方式，例如，文件、数据库及程序内参数式存储、网络存储等。对于参数式存储时，使用的就是Map类。Map本身是Interface，Java基于该接口实现三个具体的Map类，分别是HashMap、TreeMap，以及EnumMap，常用的为HashMap，本文也主要介绍HashMap。  </p><p>Map定义了访问特定集合的标准方法，这种集合用来存储key-value类型的键值对，比如，对于name:Haiii和 age:22这两组数据来讲，其中name、age称为键（key），与此对应的是键值（value）。在一个Map集合类中,每对键或值其类型都可以是 任意的,比如int、String等都是可以的。  </p><p>Map类又是一个类模板，一个Map类对象在初始化时必须指定键的类型，可以是任何Object类，比如，Map&lt;String,Object&gt; mMap= new HashMap&lt;String,Object&gt;()。<br>&lt;&gt;里面的数据类型用于指定Map集合中“键值对”的类型。 </p><p>  <em>表1-1 Map集合添加和删除键值对的方法</em></p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">clear()</td><td style="text-align:left">删除该Map集合中的全部元素</td></tr><tr><td style="text-align:left">remove(Objectkey)</td><td style="text-align:left">删除键名为key所对应的键值对</td></tr><tr><td style="text-align:left">put(Objectkey,Objectvalue)</td><td style="text-align:left">添加一个新的键值对</td></tr><tr><td style="text-align:left">putAll(Mapmap)</td><td style="text-align:left">将该Map集合的元素全部复制到新的Map中</td></tr></tbody></table><hr><p>Map类没有提供直接遍历键值对的方法，要遍历所有键值对需要一个中间过程。Map提供了3个方法用于间接遍历键值对，如下：  </p><ul><li>entrySet() 返回所有键值对类型为Set对象。</li><li>keySet() 返回所有键值对类型为Set对象。</li><li>valueSet() 返回所有键值对类型为Collection对象。<br>要得到具体的键值对，需要再解析Set和Collection对象，但仅有这两个对象还不能获得键值对，还需要借助于Iterator类。到这里，可能觉得有些复杂，别着急，结果马上就要出来了。<br>Set、Collection、Iterator实际上是Map内部进行操作的3个辅助类，要得到具体Map键值对，如代码清单1-1所示。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; mMap = new HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">    Iterator kv = mMap.entrySet().iterator();</span><br><span class="line">    Iterator k = mMap.keySet().iterator();</span><br><span class="line">    Iterator v = mMap.values().iterator();</span><br><span class="line"></span><br><span class="line">    Int size = mMap.size();</span><br><span class="line">    for(int i = 0;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Map.Entryentry = (Map.Entry)kv.next();</span><br><span class="line">        Object key = entry.getKey();</span><br><span class="line">        Object value = entry.getValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>用以上代码读取键值对时，Object可以强制转换为int类型。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Map类的使用方法&quot;&gt;&lt;a href=&quot;#Android-Map类的使用方法&quot; class=&quot;headerlink&quot; title=&quot;Android Map类的使用方法&quot;&gt;&lt;/a&gt;Android Map类的使用方法&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Bundle-savedInstanceState</title>
    <link href="http://yoursite.com/2019/03/29/Bundle-savedInstanceState/"/>
    <id>http://yoursite.com/2019/03/29/Bundle-savedInstanceState/</id>
    <published>2019-03-29T15:17:33.000Z</published>
    <updated>2019-03-29T15:19:10.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="onCreate（）方法中的参数Bundle-savedInstanceState-的意义用法"><a href="#onCreate（）方法中的参数Bundle-savedInstanceState-的意义用法" class="headerlink" title="onCreate（）方法中的参数Bundle savedInstanceState 的意义用法"></a>onCreate（）方法中的参数Bundle savedInstanceState 的意义用法</h1> <a id="more"></a><p> Activity中有一个名称叫onCreate的方法。该方法是在Activity创建时被系统调用，是一个Activity生命周期的开始。可是有一点容易被忽视，就是onCreate方法的参数saveInsanceState。一般的程序开发中，很少用到这个参数。<br>onCreate方法的完整定义如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void onCreate(Bundle saveInsanceState)&#123;</span><br><span class="line">               super.onCreate(saveInsanceState);  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>Bundle类型的数据与Map类型的数据相似，都是以key-value的形式存储数据的。<br>从字面上看saveInsanceState，是保存实例状态的。实际上，saveInsanceState也就是保存Activity的状态的。那么，saveInsanceState中的状态数据是从何处而来的呢？下面我们介绍Activity的另一个方法saveInsanceState。<br>onsaveInsanceState方法是用来保存Activity的状态的。当一个Activity在生命周期结束前，会调用该方法保存状态。<br>如下所示：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> public void onSaveInsanceState(Bundle saveInsanceState)&#123;</span><br><span class="line">    super.onSaveInsanceState(saveInsanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际应用中，当一个Activity结束前，如果需要保存状态，就在onsaveInsanceState中，将状态数据以key-value的形式放入到saveInsanceState中。这样，当一个Activity被创建时，就能从onCreate的参数saveInsanceState中获得状态数据。<br>状态这个参数在实现应用中有很大的用途，比如：一个游戏在退出前，保存一下当前游戏运行的状态，当下次开启时能接着上次的继续玩下去。再比如：电子书程序，当一本小说被阅读到第199页后退出了（不管是内存不足还是用户自动关闭程序），当下次打开时，读者可能已忘记了上次已阅读到第几页了，但是，读者想接着上次的读下去。如果采用saveInstallState参数，就很容易解决上述问题。</p><p>使用例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import android.app.Activity;</span><br><span class="line"> import android.os.Bundle;</span><br><span class="line"> import android.util.Log</span><br><span class="line">public class AndroidTest extends Activity &#123;</span><br><span class="line">      private static final String TAG = &quot;MyNewLog&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        // If an instance of this activity had previously stopped, we can get the original text it started with.</span><br><span class="line">        if(null != savedInstanceState)</span><br><span class="line">        &#123;//因为Activity的生命周期原因 ，if 语句放着不一定能执行得到 应该结合实际情况</span><br><span class="line">               int IntTest = savedInstanceState.getInt(&quot;IntTest&quot;);</span><br><span class="line">               String StrTest = savedInstanceState.getString(&quot;StrTest&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">    &#125;</span><br><span class="line">      @Override</span><br><span class="line">    public void onSaveInstanceState(Bundle savedInstanceState) &#123;</span><br><span class="line">        // Save away the original text, so we still have it if the activity needs to be killed while paused.</span><br><span class="line">      savedInstanceState.putInt(&quot;IntTest&quot;, 0);</span><br><span class="line">      savedInstanceState.putString(&quot;StrTest&quot;, &quot;savedInstanceState test&quot;);</span><br><span class="line">      super.onSaveInstanceState(savedInstanceState);</span><br><span class="line">       &#125;</span><br><span class="line">   @Override</span><br><span class="line">    public void onRestoreInstanceState(Bundle savedInstanceState) &#123;</span><br><span class="line">      super.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">      int IntTest = savedInstanceState.getInt(&quot;IntTest&quot;);</span><br><span class="line">      String StrTest = savedInstanceState.getString(&quot;StrTest&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;onCreate（）方法中的参数Bundle-savedInstanceState-的意义用法&quot;&gt;&lt;a href=&quot;#onCreate（）方法中的参数Bundle-savedInstanceState-的意义用法&quot; class=&quot;headerlink&quot; title=&quot;onCreate（）方法中的参数Bundle savedInstanceState 的意义用法&quot;&gt;&lt;/a&gt;onCreate（）方法中的参数Bundle savedInstanceState 的意义用法&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>android跳转-addFlags.md</title>
    <link href="http://yoursite.com/2019/03/29/android%E8%B7%B3%E8%BD%AC-addFlags-md/"/>
    <id>http://yoursite.com/2019/03/29/android跳转-addFlags-md/</id>
    <published>2019-03-29T06:57:00.000Z</published>
    <updated>2019-03-29T15:11:24.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android跳转-addFlags"><a href="#android跳转-addFlags" class="headerlink" title="android跳转-addFlags"></a>android跳转-addFlags</h1><a id="more"></a><p>Activity的两种启动模式：FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_REORDER_TO_FRONT</p><ol><li>如果已经启动了四个Activity：A，B，C和D。在D Activity里，我们要跳到B Activity，同时希望C finish掉，可以在startActivity(intent)里的intent里添加flags标记，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(this, B.class);   </span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);  </span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li></ol><p>这样启动B Activity，就会把D，C都finished掉，如果你的B Activity的启动模式是默认的（multiple） ，则B Activity会finished掉，再启动一个新的Activity B。<br>  如果不想重新再创建一个新的B Activity，则在上面的代码里再加上：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);</span><br></pre></td></tr></table></figure></p><p>  这样B Activity就不会再创建一个新的了，而是会重用之前的B Activity，同时调用B Activity的onNewIntent()方法。  </p><hr><ol start="2"><li>如果已经启动了四个Activity：A，B，C和D，在D Activity里，想再启动一个Actvity B，但不变成A,B,C,D,B，而是希望是A,C,D,B，则可以像下面写代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  Intent intent = new Intent(this, MainActivity.class);  </span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);   </span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;android跳转-addFlags&quot;&gt;&lt;a href=&quot;#android跳转-addFlags&quot; class=&quot;headerlink&quot; title=&quot;android跳转-addFlags&quot;&gt;&lt;/a&gt;android跳转-addFlags&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>离散数学-范式</title>
    <link href="http://yoursite.com/2019/03/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/19/离散数学-范式/</id>
    <published>2019-03-19T03:04:55.000Z</published>
    <updated>2019-03-19T03:04:55.189Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python安装</title>
    <link href="http://yoursite.com/2019/03/19/Python%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/03/19/Python安装/</id>
    <published>2019-03-18T16:05:36.000Z</published>
    <updated>2019-03-18T17:49:37.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PyCharm的安装"><a href="#PyCharm的安装" class="headerlink" title="PyCharm的安装"></a>PyCharm的安装</h1><p>这个文章算是一个帮助文档吧。︿(￣︶￣)︿<br><a id="more"></a><br>废话不多说  </p><ul><li>第一步，安装Python（注意，这个不是编译器）</li></ul><p><img src="/2019/03/19/Python安装/1.PNG" alt><br>–&gt;<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">￥￥￥python官方下载网址￥￥￥</a><br>–&gt;<em>一定要记住自己的安装路径，要不然找起来很麻烦的,别问我怎么知道的</em><br><img src="/2019/03/19/Python安装/3.jpg" alt> </p><p>这个过程是为了让你的电脑有一个能编译Python的环境，装上它，配置好环境，你就能在电脑上写python。<br>但是——下载完成后，还不不能直接编写python。 </p><hr><p><strong>现在有两种方法供你选择（如果你想简单一点的话，可以直接看方法2）</strong>：</p><h2 id="一-配置环境变量法"><a href="#一-配置环境变量法" class="headerlink" title="一.配置环境变量法"></a>一.配置环境变量法</h2><p>正如之前所说，你需要给电脑配置一个环境，那么现在就涉及到环境变量的配置上了。  </p><ul><li>第一步，右击我的电脑，找到属性，点击。<br>然后点击高级系统设置。<br><img src="/2019/03/19/Python安装/4.PNG" alt>   </li><li>点击环境变量<br><img src="/2019/03/19/Python安装/5.PNG" alt>    </li><li>然后就在系统变量里面找，找一个叫Path或者PATH的东西，别管它是干嘛的，找就行了。<br><img src="/2019/03/19/Python安装/6.PNG" alt>   </li><li>哇，找到了！╰(￣▽￣)╭<br><img src="/2019/03/19/Python安装/7.PNG" alt>   </li><li>双击它，然后就会弹出一个好奇妙的东西<br><img src="/2019/03/19/Python安装/8.PNG" alt>   </li><li>我早就提醒过你去记住安装路径的。比如我的就被默认安装到了C盘<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\han1254\AppData\Local\Programs\Python\Python37-32</span><br></pre></td></tr></table></figure></li></ul><p>把你的路径复制下来，然后找一个空白的格子，双击，然后粘贴进去<br><img src="/2019/03/19/Python安装/9.PNG" alt>   </p><ul><li>接下来就是要见证奇迹了<br>按住电脑的win键（就是那个画着Windows图标的键）和字母R键，<br>会出现这么个鬼东西<br><img src="/2019/03/19/Python安装/10.PNG" alt>   </li><li>像我一样，在里面输入cmd,回车<br><img src="/2019/03/19/Python安装/11.PNG" alt><br>哇，黑框框 </li><li>输入<code>python</code> ，出现下图情况，估计就可以了<br><img src="/2019/03/19/Python安装/13.PNG" alt> </li><li>接下来你就可以写程序了<br><img src="/2019/03/19/Python安装/14.PNG" alt> </li><li><h2 id="然而你是不会甘愿就对着个黑框框写程序的"><a href="#然而你是不会甘愿就对着个黑框框写程序的" class="headerlink" title="然而你是不会甘愿就对着个黑框框写程序的"></a>然而你是不会甘愿就对着个黑框框写程序的</h2>所以，要用一个颜值高一点的编译器<br>当~当~当~当，PyCharm<br><img src="/2019/03/19/Python安装/15.PNG" alt><br>–&gt;<a href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">PyCharm下载链接</a><br>记住，下载community版本的，professional的太大了。<br><img src="/2019/03/19/Python安装/16.PNG" alt><br>然后下载安装就行了。<br>在开始页面新建project，会出现如下界面<br><img src="/2019/03/19/Python安装/17.PNG" alt><br>untitle说明没有名字，改个名字，不改也行，我改成hello,示范一下。<br><img src="/2019/03/19/Python安装/18.PNG" alt><br>然后在我标的地方，右键-&gt;new-&gt;PythonFile,写代码，运行<br><img src="/2019/03/19/Python安装/21.PNG" alt></li></ul><h2 id="二-直接法"><a href="#二-直接法" class="headerlink" title="二.直接法"></a>二.直接法</h2><ul><li>第一步，下载python</li><li>第二步，下载PyCharm</li><li>第三步，如果你没有配置环境的话，那么下图里，我画红圈的地方是啥都没有的。</li></ul><p><img src="/2019/03/19/Python安装/22.PNG" alt><br>点击省略号<br><img src="/2019/03/19/Python安装/24.PNG" alt><br>再点击，他会出现一个树状图让你选文件夹，也就是你下载python的文件夹。<br><img src="/2019/03/19/Python安装/25.PNG" alt><br>大概就像这个图里显示的路径一样，一定要选到python.exe<br><img src="/2019/03/19/Python安装/26.PNG" alt><br>不要忘了勾选这个，要不你每次创建项目都要设置<br><img src="/2019/03/19/Python安装/27.PNG" alt></p><h2 id="电脑快没电了，如果我的教程不清楚，下面还有一个"><a href="#电脑快没电了，如果我的教程不清楚，下面还有一个" class="headerlink" title="电脑快没电了，如果我的教程不清楚，下面还有一个"></a>电脑快没电了，如果我的教程不清楚，下面还有一个</h2><p><a href="http://www.runoob.com/w3cnote/pycharm-windows-install.html" target="_blank" rel="noopener">PyCharm 安装教程（Windows）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PyCharm的安装&quot;&gt;&lt;a href=&quot;#PyCharm的安装&quot; class=&quot;headerlink&quot; title=&quot;PyCharm的安装&quot;&gt;&lt;/a&gt;PyCharm的安装&lt;/h1&gt;&lt;p&gt;这个文章算是一个帮助文档吧。︿(￣︶￣)︿&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="pycharm的安装" scheme="http://yoursite.com/categories/Python/pycharm%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="install" scheme="http://yoursite.com/tags/install/"/>
    
  </entry>
  
  <entry>
    <title>Adapter</title>
    <link href="http://yoursite.com/2019/03/18/Adapter/"/>
    <id>http://yoursite.com/2019/03/18/Adapter/</id>
    <published>2019-03-18T14:10:09.000Z</published>
    <updated>2019-03-18T14:12:04.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h1><p>在安卓学习中经常碰到适配器，之前都是按照书上的代码去写，今天看了一下Java教材，发现了它的用法。</p><blockquote><p>适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作<br><a id="more"></a></p></blockquote><p>适配器属于结构模式<br>结构目标包含：  </p><ul><li>目标  </li><li>被适配者  </li><li>适配者 </li></ul><h2 id="一-类适配器"><a href="#一-类适配器" class="headerlink" title="一.类适配器"></a>一.类适配器</h2><p>原理：通过继承实现适配<br>当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后再继承接口B的实现类BB，这样我们可以在适配器P中访问接口B的方法了，这时我们在适配器P中的接口A方法中直接引用BB中的合适方法，这样就完成了一个简单的类适配器。  </p><blockquote><p>详见下方实例：我们以ps2与usb的转接为例  </p></blockquote><p>ps2接口：Ps2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Ps2 &#123;</span><br><span class="line">     void isPs2();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>USB接口：Usb<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> public interface Usb &#123;</span><br><span class="line">    void isUsb();</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">USB接口实现类：Usber</span><br></pre></td></tr></table></figure></p><p>public class Usber implements Usb {</p><pre><code>@Overridepublic void isUsb() {    System.out.println(&quot;USB口&quot;);}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">适配器：Adapter</span><br></pre></td></tr></table></figure></p><p>public class Adapter extends Usber implements Ps2 {</p><pre><code>@Overridepublic void isPs2() {    isUsb();}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试方法：Clienter</span><br></pre></td></tr></table></figure></p><p>public class Clienter {</p><pre><code>public static void main(String[] args) {    Ps2 p = new Adapter();    p.isPs2();}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显示结果：</span><br></pre></td></tr></table></figure></p><p>USB口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 二.对象适配器模式 ##</span><br><span class="line">　　原理：通过组合来实现适配器功能。  </span><br><span class="line">　　当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后在适配器P中定义私有变量C（对象）（B接口指向变量名），再定义一个带参数的构造器用来为对象C赋值，再在A接口的方法实现中使用对象C调用其来源于B接口的方法。</span><br><span class="line">&gt;下方实例用直流电和交流电之间的转换来演示    </span><br><span class="line"></span><br><span class="line">Target：DirectCurrent接口</span><br></pre></td></tr></table></figure></p><p>//目标<br>public interface DirectCurrent {<br>    public String giveDirectCurrent();</p><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Adaptee: 一个已经存在的接口或者抽象类 在本例子中就是      AlternateCurrent接口。</span><br></pre></td></tr></table></figure></p><p>//被适配者(Adaptee)，一个已经存在的接口或者抽象类<br>public interface AlternateCurrent {<br>    public String giveAlternateCrruent();</p><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Adapter: 对被适配者接口（抽象类）与目标接口进行适配。本例中为ElectricAdapter</span><br></pre></td></tr></table></figure></p><p>public class ElectricAdapter implements DirectCurrent{</p><pre><code>AlternateCurrent out;ElectricAdapter(AlternateCurrent out) {    this.out=out;}@Overridepublic String giveDirectCurrent() {    String m = out.giveAlternateCrruent();    StringBuffer str = new StringBuffer(m);    for(int i=0;i&lt;str.length();i++) {        if(str.charAt(i)==&apos;0&apos;)        {            str.setCharAt(i, &apos;1&apos;);        }    }    m=new String(str);    return m;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application</span><br></pre></td></tr></table></figure><p>public class Application {<br>    public static void main(String[] args) {<br>        AlternateCurrent aElectric = new PowerCompany();<br>        Wash wash = new Wash();<br>        wash.turnOn(aElectric);<br>        DirectCurrent dElectric = new ElectricAdapter(aElectric);<br>        Recorder recorder = new Recorder();<br>        recorder.turnOn(dElectric);</p><pre><code>}</code></pre><p>}<br>class PowerCompany implements AlternateCurrent{</p><pre><code>public String giveAlternateCrruent() {    return &quot;101010101010101010&quot;;}    </code></pre><p>}<br>class Wash{<br>    String name;<br>    Wash(){<br>        name=”洗衣机”;<br>    }<br>    Wash(String s){<br>        name=s;<br>    }<br>    public void turnOn(AlternateCurrent a) {<br>        String s= a.giveAlternateCrruent();<br>        System.out.println(name+”使用交流电：\n”+s);<br>        System.out.println(“开始洗衣服”);<br>    }<br>}<br>class Recorder{<br>    String name;<br>    Recorder(){<br>        name=”录音机”;<br>    }<br>    Recorder(String s){<br>        name=s;<br>    }<br>    public void turnOn(DirectCurrent a) {<br>        String s = a.giveDirectCurrent();<br>        System.out.println(name+”使用直流电：\n”+s);<br>        System.out.println(“开始录音”);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br></pre></td></tr></table></figure></p><p>洗衣机使用交流电：<br>101010101010101010<br>开始洗衣服<br>录音机使用直流电：<br>111111111111111111<br>开始录音<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 三.接口适配器模式 ##</span><br><span class="line">　　原理：通过抽象类来实现适配，这种适配稍别于上面所述的适配。  </span><br><span class="line">　　当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，如果我们直接实现接口，那么我们要对所有的方法进行实现，哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，这时我们可以使用一个抽象类作为中间件，即适配器，用这个抽象类实现接口，而在抽象类中所有的方法都进行置空，那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。  </span><br><span class="line">目标接口：A</span><br></pre></td></tr></table></figure></p><p>public interface A {<br>    void a();<br>    void b();<br>    void c();<br>    void d();<br>    void e();<br>    void f();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">适配器：Adapter</span><br></pre></td></tr></table></figure></p><p>public abstract class Adapter implements A {<br>    public void a(){}<br>    public void b(){}<br>    public void c(){}<br>    public void d(){}<br>    public void e(){}<br>    public void f(){}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">实现类：Ashili</span><br></pre></td></tr></table></figure></p><p>public class Ashili extends Adapter {<br>    public void a(){<br>        System.out.println(“实现A方法被调用”);<br>    }<br>    public void d(){<br>        System.out.println(“实现d方法被调用”);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">测试类：Clienter</span><br></pre></td></tr></table></figure></p><p>public class Clienter {</p><pre><code>public static void main(String[] args) {    A a = new Ashili();    a.a();    a.d();}</code></pre><p>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Adapter&quot;&gt;&lt;a href=&quot;#Adapter&quot; class=&quot;headerlink&quot; title=&quot;Adapter&quot;&gt;&lt;/a&gt;Adapter&lt;/h1&gt;&lt;p&gt;在安卓学习中经常碰到适配器，之前都是按照书上的代码去写，今天看了一下Java教材，发现了它的用法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开学一周回顾</title>
    <link href="http://yoursite.com/2019/03/08/%E5%BC%80%E5%AD%A6%E4%B8%80%E5%91%A8%E5%9B%9E%E9%A1%BE/"/>
    <id>http://yoursite.com/2019/03/08/开学一周回顾/</id>
    <published>2019-03-08T13:30:32.000Z</published>
    <updated>2019-03-08T14:14:54.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开学一周回顾"><a href="#开学一周回顾" class="headerlink" title="开学一周回顾"></a>开学一周回顾</h1><p>第一周做的事情还挺多的，无论是班级事务还是学习，感觉还算充实。<br><a id="more"></a> </p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>安卓学习了ListView，并且给列表里的按钮配上了相应的活动，做成了一个水果小百科的形式，学会了在工程中新建类。<br><img src="/2019/03/08/开学一周回顾/1.jpg" alt><img src="/2019/03/08/开学一周回顾/2.jpg" alt></li><li>高数学到线性微分方程，前面还可以，但学到高阶线性的时候就蒙圈了  </li><li>用Java刷了一道PTA，用C++刷了一道题，学了容器、迭代器的一些用法。<br>–&gt;<a href="https://han1254.github.io/2019/03/05/PTA-旧键盘/" target="_blank" rel="noopener">PTA-旧键盘</a><br>–&gt;<a href="https://han1254.github.io/2019/03/04/PTA-科学计数法/" target="_blank" rel="noopener">PTA-科学计数法</a>    </li></ul><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li>AS无法添加依赖库，书的版本跟现在的AS的版本不同，网上也没看到最新版本的教程，所以没法写，用不了RecyclerView.</li><li>Java学习的太慢，下周应该加速学习。要继续看网课。  </li><li>高数，离散，需要借助周末的时间赶紧复习。</li></ul><hr><h2 id="班级"><a href="#班级" class="headerlink" title="班级"></a>班级</h2><ul><li>发书  </li><li>班委会  </li><li>专业大会  </li><li>拍班级宣传视频  </li><li>重置快闪ppt  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开学一周回顾&quot;&gt;&lt;a href=&quot;#开学一周回顾&quot; class=&quot;headerlink&quot; title=&quot;开学一周回顾&quot;&gt;&lt;/a&gt;开学一周回顾&lt;/h1&gt;&lt;p&gt;第一周做的事情还挺多的，无论是班级事务还是学习，感觉还算充实。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="大一" scheme="http://yoursite.com/categories/%E5%A4%A7%E4%B8%80/"/>
    
      <category term="第二学期" scheme="http://yoursite.com/categories/%E5%A4%A7%E4%B8%80/%E7%AC%AC%E4%BA%8C%E5%AD%A6%E6%9C%9F/"/>
    
      <category term="第一周" scheme="http://yoursite.com/categories/%E5%A4%A7%E4%B8%80/%E7%AC%AC%E4%BA%8C%E5%AD%A6%E6%9C%9F/%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="PTA" scheme="http://yoursite.com/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>PTA-旧键盘</title>
    <link href="http://yoursite.com/2019/03/05/PTA-%E6%97%A7%E9%94%AE%E7%9B%98/"/>
    <id>http://yoursite.com/2019/03/05/PTA-旧键盘/</id>
    <published>2019-03-05T11:44:31.000Z</published>
    <updated>2019-03-05T12:15:24.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1029-旧键盘-（20-分）"><a href="#1029-旧键盘-（20-分）" class="headerlink" title="1029 旧键盘 （20 分）"></a>1029 旧键盘 （20 分）</h1><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。<br><a id="more"></a><br>输入格式：  </p><blockquote><p>输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 _（代表空格）组成。题目保证 2 个字符串均非空。  </p></blockquote><p>输出格式：  </p><blockquote><p>按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。  </p></blockquote><p>输入样例：  </p><blockquote><p>7_This_is_a_test  </p></blockquote><blockquote><p>_hs_s_a_es  </p></blockquote><p>输出样例：  </p><blockquote><p>7TI<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 1029.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string input, output;</span><br><span class="line">    vector&lt;char&gt; v;</span><br><span class="line"></span><br><span class="line">    getline(cin, input);</span><br><span class="line">    getline(cin, output);</span><br><span class="line"></span><br><span class="line">    for (int i = 0,j=0; i &lt; input.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (input[i] != output[j])//如果不同即为缺失的</span><br><span class="line">        &#123;</span><br><span class="line">            if (islower(input[i]))//如果是小写，转为大写</span><br><span class="line">                input[i]=toupper(input[i]);</span><br><span class="line"></span><br><span class="line">            v.push_back(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            ++j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;char&gt;::iterator i,begin = v.begin(), end = v.end();</span><br><span class="line"></span><br><span class="line">    for (i = begin; i != end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (find(begin, i, *i) == i)//如果前面未出现则输出（即发现*i的位置在i上）</span><br><span class="line">            cout &lt;&lt; *i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="知识点总结："><a href="#知识点总结：" class="headerlink" title="知识点总结："></a>知识点总结：</h2><ul><li><code>vector&lt;char&gt; v</code><br>创建一个char型的vector。<br>–&gt;<a href="https://www.cnblogs.com/zsq1993/p/5929806.html" target="_blank" rel="noopener">vector常用函数</a>   </li><li><code>v.push_back(input[i])</code><br>往容器里添加数据</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (islower(input[i]))//如果是小写，转为大写</span><br><span class="line">                input[i]=toupper(input[i]);</span><br></pre></td></tr></table></figure><p>大小写转换。  </p></li><li><code>vector&lt;char&gt;::iterator i</code><br>迭代器<br>–&gt;<a href="https://www.cnblogs.com/hdk1993/p/4419779.html" target="_blank" rel="noopener">c++迭代器（iterator）详解 </a>    </li><li><code>find(begin, i, *i) == i</code><br>–&gt;<a href="https://blog.csdn.net/sinat_34328764/article/details/79946650" target="_blank" rel="noopener">C++ find函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1029-旧键盘-（20-分）&quot;&gt;&lt;a href=&quot;#1029-旧键盘-（20-分）&quot; class=&quot;headerlink&quot; title=&quot;1029 旧键盘 （20 分）&quot;&gt;&lt;/a&gt;1029 旧键盘 （20 分）&lt;/h1&gt;&lt;p&gt;旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="迭代器的使用" scheme="http://yoursite.com/categories/C/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="PTA" scheme="http://yoursite.com/tags/PTA/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Android-PressBarr重复出现</title>
    <link href="http://yoursite.com/2019/03/04/Android-PressBarr%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/04/Android-PressBarr重复出现/</id>
    <published>2019-03-04T14:21:18.000Z</published>
    <updated>2019-03-04T14:21:18.487Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PTA-科学计数法</title>
    <link href="http://yoursite.com/2019/03/04/PTA-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/04/PTA-科学计数法/</id>
    <published>2019-03-04T05:05:15.000Z</published>
    <updated>2019-03-05T12:32:55.857Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目要求：</strong><br>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表  达式<br><code>[+-][1-9].[0-9]+E[+-][0-9]+</code>，<br>即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。<br>现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。<br><a id="more"></a><br>输入格式：<br>每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。<br>输出格式：<br>对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。<br>输入样例 1：<br><code>+1.23400E-03</code><br>输出样例 1：<br><code>0.00123400</code><br>输入样例 2：<br><code>-1.2E+10</code><br>输出样例 2：<br><code>-12000000000</code><br><strong>我的代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) </span><br><span class="line">&#123;</span><br><span class="line">Scanner t=new Scanner(System.in);</span><br><span class="line">String s=t.next();</span><br><span class="line">String[] d = s.split(&quot;[.E]&quot;);</span><br><span class="line">t.close();</span><br><span class="line">int ex = Integer.parseInt(d[2]);//E后面的数（即整数），转化成整数</span><br><span class="line">int in = Integer.parseInt(d[0]);//小数点前的数，转化成整数</span><br><span class="line">if(ex&gt;=0)//指数大于零</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(in);</span><br><span class="line">boolean h=false;//判断新数是不是有小数点</span><br><span class="line">if(ex&lt;d[1].length())//指数小于小数位数的时候</span><br><span class="line">&#123;</span><br><span class="line">h=true;</span><br><span class="line">&#125;</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;d[1].length()&amp;&amp;ex&gt;0;i++,ex--)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(d[1].charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">if(h)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(&quot;.&quot;);</span><br><span class="line">for(;i&lt;d[i].length();i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(d[i].charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(ex!=0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(0);</span><br><span class="line">ex--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else//指数小于零</span><br><span class="line">&#123;</span><br><span class="line">if(in&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(&quot;-&quot;);</span><br><span class="line">in=-in;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;0.&quot;);</span><br><span class="line">    for(int i=0;i&lt;(-ex)-1;i++)//(-ex)-1是重点,因为例如：1.92E-2=0.0192，小数点后到一之间只有一个零</span><br><span class="line">    &#123;</span><br><span class="line">    System.out.print(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">System.out.print(in);</span><br><span class="line">System.out.print(d[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体思路应该是对的，但是有一个测试点错误，两个超时。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目要求：&lt;/strong&gt;&lt;br&gt;科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表  达式&lt;br&gt;&lt;code&gt;[+-][1-9].[0-9]+E[+-][0-9]+&lt;/code&gt;，&lt;br&gt;即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。&lt;br&gt;现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PTA" scheme="http://yoursite.com/categories/PTA/"/>
    
      <category term="科学计数法" scheme="http://yoursite.com/categories/PTA/%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="PTA" scheme="http://yoursite.com/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>PTA--进制转换</title>
    <link href="http://yoursite.com/2019/03/02/PTA-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/03/02/PTA-进制转换/</id>
    <published>2019-03-02T13:05:35.000Z</published>
    <updated>2019-03-02T14:32:39.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="22-D进制的A-B（Java）"><a href="#22-D进制的A-B（Java）" class="headerlink" title="22. D进制的A+B（Java）"></a>22. D进制的A+B（Java）</h1><p>题目要求：  </p><blockquote><p>输入两个非负 10 进制整数 A 和 B (≤2^30−1)，输出 A+B 的 D (1&lt;D≤10)进制数。  </p></blockquote><blockquote><p><strong>输入格式</strong>：<br>输入在一行中依次给出 3 个整数 A、B 和 D。<br><a id="more"></a><br><strong>输出格式</strong>：<br>输出 A+B 的 D 进制数。   </p></blockquote><blockquote><p>输入样例：<br>123 456 8<br>输出样例：<br>1103   </p></blockquote><p><em>解析：其实这样的题不算难，但是自己老是记不住进制转换的方法，记录一下这个题，顺便用Java来实现一下。</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">//int范围[-2^31-(2^31-1)]</span><br><span class="line"></span><br><span class="line">int A = in.nextInt();</span><br><span class="line"></span><br><span class="line">int B = in.nextInt();</span><br><span class="line"></span><br><span class="line">int D = in.nextInt();</span><br><span class="line"></span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line">int sum = A + B;</span><br><span class="line"></span><br><span class="line">//用于将余数插入到StringBuffer中</span><br><span class="line"></span><br><span class="line">StringBuffer string = new StringBuffer();</span><br><span class="line"></span><br><span class="line">while(sum != 0)&#123;</span><br><span class="line"></span><br><span class="line">int temp = sum % D;</span><br><span class="line"></span><br><span class="line">string.append(temp);</span><br><span class="line"></span><br><span class="line">sum /= D;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对StringBuffer内容进行倒序</span><br><span class="line"></span><br><span class="line">string.reverse();</span><br><span class="line"></span><br><span class="line">System.out.println(string);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这时候我就疑惑了：`StringBuffer`是个什么鬼？  </span><br><span class="line">详情参见[菜鸟教程](http://www.runoob.com/java/java-stringbuffer.html)  </span><br><span class="line">&gt;**Java StringBuffer 和 StringBuilder 类**</span><br><span class="line"></span><br><span class="line">&gt;当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 </span><br><span class="line">和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 </span><br><span class="line">StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 </span><br><span class="line">由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">Test.java 文件代码：</span><br></pre></td></tr></table></figure></p><p>public class Test{<br>  public static void main(String args[]){<br>    StringBuffer sBuffer = new StringBuffer(“菜鸟教程官网：”);<br>    sBuffer.append(“www”);<br>    sBuffer.append(“.runoob”);<br>    sBuffer.append(“.com”);<br>    System.out.println(sBuffer);<br>  }<br>}<br><code>`</code><br>结果：  </p><blockquote><p>菜鸟教程官网：<a href="http://www.runoob.com" target="_blank" rel="noopener">www.runoob.com</a></p></blockquote><p><strong>StringBuffer 方法</strong><br>序号|方法描述<br>-|-|-<br>1|public StringBuffer append(String s):将指定的字符串追加到此字符序列。<br>2| public StringBuffer reverse():将此字符序列用其反转形式取代。<br>3|public delete(int start, int end):移除此序列的子字符串中的字符。<br>4| public insert(int offset, int i):将 int 参数的字符串表示形式插入此序列中<br>5|replace(int start, int end, String str):使用给定 String 中的字符替换此序列的子字符串中的字符。<br>最后的结果如下：<br><img src="/2019/03/02/PTA-进制转换/1.PNG" alt>  </p><ul><li>还是只有一个测试点通不过，醉了。<strong>…（⊙＿⊙；）…</strong>  </li><li>为啥表格显示不出来？  </li><li>文字为啥跑到代码里面去了<strong>╮（╯＿╰）╭</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;22-D进制的A-B（Java）&quot;&gt;&lt;a href=&quot;#22-D进制的A-B（Java）&quot; class=&quot;headerlink&quot; title=&quot;22. D进制的A+B（Java）&quot;&gt;&lt;/a&gt;22. D进制的A+B（Java）&lt;/h1&gt;&lt;p&gt;题目要求：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入两个非负 10 进制整数 A 和 B (≤2^30−1)，输出 A+B 的 D (1&amp;lt;D≤10)进制数。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;：&lt;br&gt;输入在一行中依次给出 3 个整数 A、B 和 D。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PTA" scheme="http://yoursite.com/categories/PTA/"/>
    
      <category term="进制转换" scheme="http://yoursite.com/categories/PTA/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="PTA" scheme="http://yoursite.com/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>PTA-Mooncake</title>
    <link href="http://yoursite.com/2019/03/02/PTA-Mooncake/"/>
    <id>http://yoursite.com/2019/03/02/PTA-Mooncake/</id>
    <published>2019-03-02T08:17:08.000Z</published>
    <updated>2019-03-02T08:31:37.748Z</updated>
    
    <content type="html"><![CDATA[<p><strong>20.题目要求：</strong>  </p><blockquote><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。<br><a id="more"></a></p></blockquote><blockquote><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。  </p></blockquote><blockquote><p>输入格式：  </p></blockquote><blockquote><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。  </p></blockquote><blockquote><p>输出格式：  </p></blockquote><blockquote><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。  </p></blockquote><blockquote><p>输入样例：<br>3 20<br>18 15 10<br>75 72 45<br>输出样例：<br>94.50  </p></blockquote><hr><p>我的解答(C++):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class mooncake&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">double cage;</span><br><span class="line">double consale;</span><br><span class="line">double ave;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(mooncake a,mooncake b)// **这个很关键，用来对对象数组进行排序**</span><br><span class="line">&#123;</span><br><span class="line">return a.ave&gt;b.ave;</span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">double s=0.0;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">double quar;</span><br><span class="line">cin&gt;&gt;quar;</span><br><span class="line">mooncake m[n];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m[i].cage;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m[i].consale;</span><br><span class="line">m[i].ave=m[i].consale/m[i].cage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sort(m,m+n,cmp);</span><br><span class="line">int t=0;</span><br><span class="line">while(quar&gt;=0)</span><br><span class="line">&#123;</span><br><span class="line">if(m[t].cage&lt;quar)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">s+=m[t].consale;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">s+=quar*m[t].ave;</span><br><span class="line">&#125;</span><br><span class="line">quar-=m[t].cage;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个测试点错了，23分。 </p><p><strong>看看网上的答案，跟我差不多：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct MoonCake&#123;</span><br><span class="line"></span><br><span class="line">double num,totalp,singlep;//3个double型的库存量，总价，单价 </span><br><span class="line"></span><br><span class="line">&#125;cakes[1000];</span><br><span class="line"></span><br><span class="line">bool cmp(MoonCake a,MoonCake b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return a.singlep&gt;b.singlep;//设计函数以降序 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int n,maxreq;//定义种类，最大需求量 </span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;maxreq;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;cakes[i].num;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;cakes[i].totalp;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">cakes[i].singlep=cakes[i].totalp/cakes[i].num;</span><br><span class="line"></span><br><span class="line">sort(cakes,cakes+n,cmp);</span><br><span class="line"></span><br><span class="line">double maxbenf=0;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(maxreq&lt;=cakes[i].num)//如果最大需求量不大于当前库存 </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">maxbenf+=cakes[i].singlep*maxreq;//最大收益即当前单价乘以最大需求量 </span><br><span class="line"></span><br><span class="line">break;//注意及时退出 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">maxbenf+=cakes[i].totalp;//否则最大收益累加当前总价 </span><br><span class="line"></span><br><span class="line">maxreq-=cakes[i].num;//需求量减去当前库存 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;maxbenf;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;20.题目要求：&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PTA" scheme="http://yoursite.com/categories/PTA/"/>
    
      <category term="Mooncake" scheme="http://yoursite.com/categories/PTA/Mooncake/"/>
    
    
      <category term="PTA" scheme="http://yoursite.com/tags/PTA/"/>
    
  </entry>
  
</feed>
